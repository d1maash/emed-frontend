This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: store/**, api/**, utils/**, types/**, coordinator/conscripts/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
api/application.ts
api/auth.ts
api/conscripts.ts
api/coordinator.ts
api/lmo.ts
api/recruit.ts
api/search.ts
store/hooks.ts
store/index.ts
store/slices/applicationSlice.ts
store/slices/authSlice.ts
store/slices/conscriptsSlice.ts
store/slices/coordinatorDashboardSlice.ts
store/slices/recruitDashboardSlice.ts
store/slices/registrationSlice.ts
store/slices/searchSlice.ts
types/application.ts
types/conscript.ts
types/registration.ts
types/user.ts
utils/api.ts
utils/apiInterceptors.ts
utils/phoneUtils.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="types/registration.ts">
// src/types/registration.ts
export interface RegistrationData {
  lastName: string
  firstName: string
  middleName: string
  iin: string
  birthDate: string
  phone: string
  email?: string
  password: string
  confirmPassword: string
  recaptchaToken: string
}

export interface VerificationData {
  phone: string
  code: string
}

export interface RecaptchaVerificationResponse {
  success: boolean
  challenge_ts?: string
  hostname?: string
  'error-codes'?: string[]
}
</file>

<file path="utils/phoneUtils.ts">
export function maskPhoneNumber(phone: string): string {
  if (!phone) return "";

  // Remove all non-digit characters except +
  const cleaned = phone.replace(/[^\d+]/g, "");

  if (cleaned.startsWith("+7") && cleaned.length === 12) {
    // +77771234567 -> +7777***4567
    return `${cleaned.slice(0, 5)}***${cleaned.slice(-4)}`;
  }

  if (cleaned.startsWith("8") && cleaned.length === 11) {
    // 87771234567 -> 8777***4567
    return `${cleaned.slice(0, 4)}***${cleaned.slice(-4)}`;
  }

  if (cleaned.startsWith("7") && cleaned.length === 11) {
    // 77771234567 -> 7777***4567
    return `${cleaned.slice(0, 4)}***${cleaned.slice(-4)}`;
  }

  return phone;
}
</file>

<file path="api/conscripts.ts">
import { api } from "@/utils/api";
// import { Conscript } from "@/types/conscript";
import { User } from "@/types/user";

export const listConscripts = async (
  search: string,
  access: string,
  isVerified?: boolean
): Promise<User[]> => {
  try {
    const response = await api.get<User[]>("/api/users/list/", {
      params: { role: "conscript", search: search, verified: isVerified },
      headers: {
        Authorization: `Bearer ${access}`,
        "Content-Type": "application/json",
      },
    });
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      throw new Error("Призывники не найдены");
    }
    throw new Error(error.response?.data?.message || "Призывники не найдены");
  }
};
</file>

<file path="api/coordinator.ts">
import { api } from "@/utils/api";

export const getCoordinatorDashboard = async (access: string) => {
  const response = await api.get(`/api/users/dashboard/coordinator/`, {
    headers: {
      Authorization: `Bearer ${access}`,
    },
  });
  return response.data;
};
</file>

<file path="api/lmo.ts">
import { LMO } from "@/types/application";
import { api } from "@/utils/api";

export const getLMOByConscript = async (
  search: string,
  access: string
): Promise<LMO[]> => {
  const response = await api.get("/api/medical/lmos/", {
    params: { search: search },
    headers: {
      Authorization: `Bearer ${access}`,
      "Content-Type": "application/json",
    },
  });
  return response.data;
};

export const getLMOById = async (
  lmoId: number,
  access: string
): Promise<LMO> => {
  const response = await api.get(`/api/medical/lmos/${lmoId}`, {
    headers: {
      Authorization: `Bearer ${access}`,
      "Content-Type": "application/json",
    },
  });
  return response.data;
};

export const assignDoctor = async (
  lmoId: number,
  doctorId: number,
  queueId: number,
  access: string
): Promise<{ doctorId: number; queueId: number }> => {
  const response = await api.post(
    `api/medical/lmos/${lmoId}/assign-doctor`,
    {
      doctor_id: doctorId,
      queue_id: queueId,
    },
    {
      headers: {
        Authorization: `Bearer ${access}`,
        "Content-Type": "application/json",
      },
    }
  );

  return response.data;
};
</file>

<file path="api/recruit.ts">
import { api } from "@/utils/api";

export const getRecruitDashboard = async (access: string) => {
  const response = await api.get(`/api/users/dashboard/conscript/`, {
    headers: {
      Authorization: `Bearer ${access}`,
    },
  });
  return response.data;
};
</file>

<file path="store/hooks.ts">
import { TypedUseSelectorHook, useDispatch, useSelector } from "react-redux";
import type { RootState, AppDispatch } from "./index";

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
</file>

<file path="store/slices/conscriptsSlice.ts">
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { listConscripts as listConscriptsApi } from "@/api/conscripts";
import { User } from "@/types/user";

export const listConscripts = createAsyncThunk<
  User[],
  { search: string; access: string; isVerified?: boolean },
  { rejectValue: string }
>(
  "conscripts/list",
  async ({ search, access, isVerified }, { rejectWithValue }) => {
    try {
      return await listConscriptsApi(search, access, isVerified);
    } catch (err: any) {
      return rejectWithValue(
        err?.response?.data?.message ||
          err.message ||
          "Не удалось получить список"
      );
    }
  }
);

interface ConscriptsState {
  data: User[] | null;
  loading: boolean;
  error: string | null;
}

const initialState: ConscriptsState = {
  data: [],
  loading: false,
  error: null,
};

const conscriptsSlice = createSlice({
  name: "conscripts",
  initialState,
  reducers: {
    clearConscripts: (s) => {
      s.data = [];
      s.error = null;
    },
    clearError: (s) => {
      s.error = null;
    },
  },
  extraReducers: (b) => {
    b.addCase(listConscripts.pending, (s) => {
      s.loading = true;
      s.error = null;
    })
      .addCase(listConscripts.fulfilled, (s, a) => {
        s.loading = false;
        s.data = a.payload;
      })
      .addCase(listConscripts.rejected, (s, a) => {
        s.loading = false;
        s.error = a.payload as string;
        s.data = null;
      });
  },
});

export const { clearConscripts } = conscriptsSlice.actions;
export default conscriptsSlice.reducer;
</file>

<file path="store/slices/coordinatorDashboardSlice.ts">
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import { getCoordinatorDashboard as getCoordinatorDashboardApi } from "@/api/coordinator";

interface CoordinatorDashboardState {
  data: any;
  loading: boolean;
  error: string | null;
}

const initialState: CoordinatorDashboardState = {
  data: null,
  loading: false,
  error: null,
};

export const getCoordinatorDashboard = createAsyncThunk(
  "coordinatorDashboard/getCoordinatorDashboard",
  async (access: string, { rejectWithValue }) => {
    try {
      const res = await getCoordinatorDashboardApi(access);
      return res;
    } catch (err: any) {
      return rejectWithValue(
        err?.response?.data?.message || "Ошибка загрузки данных"
      );
    }
  }
);

const coordinatorDashboardSlice = createSlice({
  name: "coordinatorDashboard",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(getCoordinatorDashboard.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(getCoordinatorDashboard.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(getCoordinatorDashboard.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export default coordinatorDashboardSlice.reducer;
</file>

<file path="store/slices/recruitDashboardSlice.ts">
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import { getRecruitDashboard as getRecruitDashboardApi } from "@/api/recruit";

interface RecruitDashboardState {
  data: any;
  loading: boolean;
  error: string | null;
}

const initialState: RecruitDashboardState = {
  data: null,
  loading: false,
  error: null,
};

export const getRecruitDashboard = createAsyncThunk(
  "recruitDashboard/getRecruitDashboard",
  async (access: string, { rejectWithValue }) => {
    try {
      const res = await getRecruitDashboardApi(access);
      return res;
    } catch (err: any) {
      return rejectWithValue(
        err?.response?.data?.message || "Ошибка загрузки данных"
      );
    }
  }
);

const recruitDashboardSlice = createSlice({
  name: "recruitDashboard",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(getRecruitDashboard.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(getRecruitDashboard.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(getRecruitDashboard.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export default recruitDashboardSlice.reducer;
</file>

<file path="store/slices/registrationSlice.ts">
// // src/store/slices/registrationSlice.ts
// import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'
// import { RegistrationData, VerificationData } from '@/types/registration'
// // import { sendVerificationCode, verifyCode } from '@/utils/api'

// interface RegistrationState {
//   formData: RegistrationData | null
//   isLoading: boolean
//   error: string | null
//   isCodeSent: boolean
//   phoneNumber: string
//   verificationAttempts: number
// }

// const initialState: RegistrationState = {
//   formData: null,
//   isLoading: false,
//   error: null,
//   isCodeSent: false,
//   phoneNumber: '',
//   verificationAttempts: 0,
// }

// export const sendPhoneVerification = createAsyncThunk(
//   'registration/sendPhoneVerification',
//   async (registrationData: RegistrationData, { rejectWithValue }) => {
//     try {
//       const response = await sendVerificationCode(registrationData)
//       return response.data
//     } catch (error: any) {
//       return rejectWithValue(error.response?.data?.message || 'Ошибка отправки кода')
//     }
//   }
// )

// export const verifyPhoneCode = createAsyncThunk(
//   'registration/verifyPhoneCode',
//   async (verificationData: VerificationData, { rejectWithValue }) => {
//     try {
//       const response = await verifyCode(verificationData)
//       return response.data
//     } catch (error: any) {
//       return rejectWithValue(error.response?.data?.message || 'Неверный код')
//     }
//   }
// )

// const registrationSlice = createSlice({
//   name: 'registration',
//   initialState,
//   reducers: {
//     setFormData: (state, action: PayloadAction<RegistrationData>) => {
//       state.formData = action.payload
//       state.phoneNumber = action.payload.phone
//     },
//     clearError: (state) => {
//       state.error = null
//     },
//     resetRegistration: (state) => {
//       return initialState
//     },
//     incrementVerificationAttempts: (state) => {
//       state.verificationAttempts += 1
//     },
//   },
//   extraReducers: (builder) => {
//     builder
//       // Send verification code
//       .addCase(sendPhoneVerification.pending, (state) => {
//         state.isLoading = true
//         state.error = null
//       })
//       .addCase(sendPhoneVerification.fulfilled, (state) => {
//         state.isLoading = false
//         state.isCodeSent = true
//       })
//       .addCase(sendPhoneVerification.rejected, (state, action) => {
//         state.isLoading = false
//         state.error = action.payload as string
//       })
//       // Verify code
//       .addCase(verifyPhoneCode.pending, (state) => {
//         state.isLoading = true
//         state.error = null
//       })
//       .addCase(verifyPhoneCode.fulfilled, (state) => {
//         state.isLoading = false
//         // Handle successful registration
//       })
//       .addCase(verifyPhoneCode.rejected, (state, action) => {
//         state.isLoading = false
//         state.error = action.payload as string
//         state.verificationAttempts += 1
//       })
//   },
// })

// export const { setFormData, clearError, resetRegistration, incrementVerificationAttempts } = registrationSlice.actions
// export default registrationSlice.reducer
</file>

<file path="types/conscript.ts">
import { User } from "@/types/user";
import { Application, LMO } from "@/types/application";

export interface Conscript {
  user: User;
  application: Application | null; // бывает, что заявки ещё нет
  lmo: LMO | null; // или ЛМО ещё не создан
}
</file>

<file path="utils/apiInterceptors.ts">
import axios from "axios";

let isRefreshing = false;
let failedQueue: any[] = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

export const setupInterceptors = (
  apiInstance: any,
  onTokenRefresh: (access: string, refresh?: string) => void,
  onLogout: () => void,
  refreshTokenFn: (
    refresh: string
  ) => Promise<{ access: string; refresh?: string }>
) => {
  apiInstance.interceptors.response.use(
    (response: any) => response,
    async (error: any) => {
      const originalRequest = error.config;

      if (
        error.response &&
        error.response.status === 401 &&
        error.response.data?.code === "token_not_valid" &&
        !originalRequest._retry
      ) {
        originalRequest._retry = true;

        if (isRefreshing) {
          return new Promise(function (resolve, reject) {
            failedQueue.push({ resolve, reject });
          })
            .then((token) => {
              originalRequest.headers["Authorization"] = "Bearer " + token;
              return apiInstance(originalRequest);
            })
            .catch((err) => {
              return Promise.reject(err);
            });
        }

        isRefreshing = true;
        const refresh = localStorage.getItem("refresh");

        if (!refresh) {
          onLogout();
          isRefreshing = false;
          return Promise.reject(error);
        }

        try {
          const data = await refreshTokenFn(refresh);
          onTokenRefresh(data.access, data.refresh || refresh);

          localStorage.setItem("access", data.access);
          if (data.refresh) localStorage.setItem("refresh", data.refresh);

          apiInstance.defaults.headers["Authorization"] =
            "Bearer " + data.access;
          processQueue(null, data.access);
          originalRequest.headers["Authorization"] = "Bearer " + data.access;

          return apiInstance(originalRequest);
        } catch (err) {
          processQueue(err, null);
          onLogout();
          return Promise.reject(err);
        } finally {
          isRefreshing = false;
        }
      }

      return Promise.reject(error);
    }
  );
};
</file>

<file path="api/application.ts">
import { api } from "@/utils/api";
import { User } from "@/types/user";
import { Application, CreateApplicationResponse } from "@/types/application";

export const createApplicationByCoordinator = async (
  iin: string,
  access: string
): Promise<CreateApplicationResponse> => {
  const response = await api.post(
    `/api/applications/create_by_coordinator/`,
    { iin },
    {
      headers: {
        Authorization: `Bearer ${access}`,
        "Content-Type": "application/json",
      },
    }
  );
  return response.data;
};

export const sendToMedical = async (
  applicationId: number,
  access: string
): Promise<{ message: string }> => {
  const response = await api.post(
    `/api/applications/${applicationId}/send_to_medical/`,
    {},
    {
      headers: {
        Authorization: `Bearer ${access}`,
        "Content-Type": "application/json",
      },
    }
  );
  return response.data;
};

export const getApplicationByConscript = async (
  search: string,
  access: string
): Promise<Application[]> => {
  const response = await api.get("/api/applications/", {
    params: { search: search },
    headers: {
      Authorization: `Bearer ${access}`,
      "Content-Type": "application/json",
    },
  });
  return response.data;
};
</file>

<file path="api/auth.ts">
import {
  api,
  getTokenCookie,
  setTokenCookie,
  removeTokenCookie,
} from "@/utils/api";

export const login = async (data: { iin: string; password: string }) => {
  const response = await api.post(`/api/users/auth/login/`, data, {
    headers: { "Content-Type": "application/json" },
  });
  setTokenCookie("access", response.data.access);
  setTokenCookie("refresh", response.data.refresh);
  return response.data;
};

export const getMe = async (access?: string) => {
  const token = access || getTokenCookie("access");
  const response = await api.get(`/api/users/me/`, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });
  return response.data;
};

export const ecpLogin = async (data: {
  p12_base64: string;
  password: string;
}) => {
  const response = await api.post(`/api/users/auth/ecp-login/`, data, {
    headers: { "Content-Type": "application/json" },
  });
  setTokenCookie("access", response.data.access);
  setTokenCookie("refresh", response.data.refresh);
  return response.data;
};

export const refreshToken = async (refresh?: string) => {
  const token = refresh || getTokenCookie("refresh");
  const response = await api.post(
    `/api/users/auth/refresh/`,
    { refresh: token },
    {
      headers: { "Content-Type": "application/json" },
    }
  );
  setTokenCookie("access", response.data.access);
  if (response.data.refresh) setTokenCookie("refresh", response.data.refresh);
  return response.data;
};

export const logout = async (access?: string) => {
  const token = access || getTokenCookie("access");
  removeTokenCookie("access");
  removeTokenCookie("refresh");
  return api.post(
    `/api/users/auth/logout/`,
    {},
    {
      headers: { Authorization: `Bearer ${token}` },
    }
  );
};
</file>

<file path="api/search.ts">
import { DoctorList, User } from "@/types/user";
import { api } from "@/utils/api";

export interface SearchUserParams {
  iin: string;
  role?: "conscript" | "coordinator" | "doctor" | "commission";
}

export type DoctorSpeciality =
  | "ФТИЗИАТР"
  | "РЕНТГЕНОЛОГ"
  | "ДЕРМАТОВЕНЕРОЛОГ"
  | "ХИРУРГ"
  | "НЕВРАПАТОЛОГ"
  | "ПСИХИАТР"
  | "НАРКОЛОГ"
  | "СТОМАТОЛОГ"
  | "ОФТАЛЬМОЛОГ"
  | "СТОМАТОЛОГ"
  | "ОТОРИНОЛАРИНГОЛОГ"
  | "ТЕРАПЕВТ";

export const searchUser = async (
  iin: SearchUserParams,
  access: string
): Promise<User> => {
  const response = await api.post(
    `/api/users/search/`,
    { iin },
    {
      headers: {
        Authorization: `Bearer ${access}`,
        "Content-Type": "application/json",
      },
    }
  );
  return response.data;
};

export const searchConscript = async (
  iin: string,
  access: string
): Promise<User> => {
  try {
    const response = await api.post(
      `/api/users/search/`,
      { iin },
      {
        headers: {
          Authorization: `Bearer ${access}`,
          "Content-Type": "application/json",
        },
      }
    );

    if (response.data.role !== "conscript") {
      throw new Error("Пользователь не является призывником");
    }
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      throw new Error("Призывник не найден");
    }
    throw new Error(error.response?.data?.message || "Призывник не найден");
  }
};

export const searchCoordinator = async (
  iin: string,
  access: string
): Promise<User> => {
  try {
    const response = await api.post(
      `/api/users/search/`,
      { iin },
      {
        headers: {
          Authorization: `Bearer ${access}`,
          "Content-Type": "application/json",
        },
      }
    );

    if (response.data.role !== "coordinator") {
      throw new Error("Пользователь не является координатором");
    }
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      throw new Error("Координатор не найден");
    }
    throw new Error(error.response?.data?.message || "Координатор не найден");
  }
};

export const searchDoctors = async (
  speciality: DoctorSpeciality,
  access: string
): Promise<DoctorList[]> => {
  try {
    const response = await api.get(`/api/users/doctors/`, {
      params: { speciality },
      headers: {
        Authorization: `Bearer ${access}`,
        "Content-Type": "application/json",
      },
    });
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      throw new Error("Доктор не найден");
    }
    throw new Error(error.response?.data?.message || "Доктор не найден");
  }
};
</file>

<file path="store/slices/applicationSlice.ts">
// store/slices/applicationSlice.ts
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import {
  createApplicationByCoordinator as createApplicationApi,
  sendToMedical as sendToMedicalApi,
  getApplicationByConscript as getApplicationByConscriptApi,
} from "@/api/application";

import {
  getLMOByConscript as getLMOByConscriptApi,
  getLMOById as getLMOByIdApi,
} from "@/api/lmo";

import {
  Application,
  CreateApplicationResponse,
  LMO,
} from "@/types/application";

interface ApplicationState {
  currentApplication: Application | null;
  currentLMO: LMO | null;
  loading: boolean;
  error: string | null;
  sendingToMedical: boolean;
  sentToMedical: boolean;
}

const initialState: ApplicationState = {
  currentApplication: null,
  currentLMO: null,
  loading: false,
  error: null,
  sendingToMedical: false,
  sentToMedical: false,
};

export const createApplicationByCoordinator = createAsyncThunk(
  "application/createByCoordinator",
  async (
    { iin, access }: { iin: string; access: string },
    { rejectWithValue }
  ) => {
    try {
      return await createApplicationApi(iin, access);
    } catch (err: any) {
      return rejectWithValue(
        err.response?.data?.message || "Ошибка создания заявки"
      );
    }
  }
);

export const sendToMedical = createAsyncThunk(
  "application/sendToMedical",
  async (
    { applicationId, access }: { applicationId: number; access: string },
    { rejectWithValue }
  ) => {
    try {
      return await sendToMedicalApi(applicationId, access);
    } catch (err: any) {
      return rejectWithValue(
        err.response?.data?.message || "Ошибка отправки на медосмотр"
      );
    }
  }
);

export const getApplicationByConscript = createAsyncThunk<
  Application | null,
  { search: string; access: string },
  { rejectValue: string }
>(
  "application/getByConscript",
  async ({ search, access }, { rejectWithValue }) => {
    try {
      const applications = await getApplicationByConscriptApi(search, access);

      return applications.length > 0 ? applications[0] : null;
    } catch (error) {
      return rejectWithValue(
        error instanceof Error ? error.message : "Unknown error"
      );
    }
  }
);

export const getLMOByConscript = createAsyncThunk<
  LMO | null,
  { search: string; access: string },
  { rejectValue: string }
>(
  "application/getLMOByConscript",
  async ({ search, access }, { rejectWithValue }) => {
    try {
      const lmos = await getLMOByConscriptApi(search, access);
      // Возвращаем первый LMO или null
      console.log(lmos[0]);
      return lmos.length > 0 ? lmos[0] : null;
    } catch (error) {
      return rejectWithValue(
        error instanceof Error ? error.message : "Unknown error"
      );
    }
  }
);

export const getLMOById = createAsyncThunk<
  LMO | null,
  { lmoId: number; access: string },
  { rejectValue: string }
>("application/getLMOById", async ({ lmoId, access }, { rejectWithValue }) => {
  try {
    const lmo = await getLMOByIdApi(lmoId, access);
    // LMO
    return lmo;
  } catch (error) {
    return rejectWithValue(
      error instanceof Error ? error.message : "Unknown error"
    );
  }
});

const applicationSlice = createSlice({
  name: "application",
  initialState,
  reducers: {
    clearApplication: (state) => {
      state.currentApplication = null;
      state.currentLMO = null;
      state.error = null;
      state.sentToMedical = false;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Create application
      .addCase(createApplicationByCoordinator.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createApplicationByCoordinator.fulfilled, (state, action) => {
        state.loading = false;
        state.currentApplication = action.payload.application;
        state.currentLMO = action.payload.lmo;
      })
      .addCase(createApplicationByCoordinator.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Get application
      .addCase(getApplicationByConscript.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(getApplicationByConscript.fulfilled, (state, action) => {
        state.loading = false;
        state.currentApplication = action.payload;
      })
      .addCase(getApplicationByConscript.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Get LMO
      .addCase(getLMOByConscript.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(getLMOByConscript.fulfilled, (state, action) => {
        state.loading = false;
        state.currentLMO = action.payload;
        if (!action.payload) {
          state.error = "ЛМО для призывника не найден";
        } else {
          state.error = null;
        }
      })
      .addCase(getLMOByConscript.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "Ошибка поиска ЛМО";
        state.currentLMO = null;
      })
      // Get LMO by id
      .addCase(getLMOById.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(getLMOById.fulfilled, (state, action) => {
        state.loading = false;
        state.currentLMO = action.payload;
        if (!action.payload) {
          state.error = "ЛМО для призывника не найден";
        } else {
          state.error = null;
        }
      })
      .addCase(getLMOById.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "Ошибка поиска ЛМО";
        state.currentLMO = null;
      })
      // Send to medical
      .addCase(sendToMedical.pending, (state) => {
        state.sendingToMedical = true;
        state.error = null;
      })
      .addCase(sendToMedical.fulfilled, (state) => {
        state.sendingToMedical = false;
        state.sentToMedical = true;
      })
      .addCase(sendToMedical.rejected, (state, action) => {
        state.sendingToMedical = false;
        state.error = action.payload as string;
      });
  },
});

export const { clearApplication, clearError } = applicationSlice.actions;
export default applicationSlice.reducer;
</file>

<file path="store/slices/searchSlice.ts">
// store/slices/searchSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import {
  searchUser as searchUserApi,
  searchConscript as searchConscriptApi,
  searchCoordinator as searchCoordinatorApi,
  SearchUserParams,
} from "@/api/search";
import { User } from "@/types/user";

interface SearchState {
  searchResults: User[] | null;
  loading: boolean;
  error: string | null;
  lastSearchParams: SearchUserParams | null;
}

const initialState: SearchState = {
  searchResults: null,
  loading: false,
  error: null,
  lastSearchParams: null,
};

export const searchUser = createAsyncThunk(
  "search/searchUser",
  async (
    { params, access }: { params: SearchUserParams; access: string },
    { rejectWithValue }
  ) => {
    try {
      const res = await searchUserApi(params, access);
      return { results: [res], params };
    } catch (err: any) {
      return rejectWithValue(
        err?.response?.data?.message ||
          err.message ||
          "Ошибка поиска пользователя"
      );
    }
  }
);

export const searchConscript = createAsyncThunk(
  "search/searchConscript",
  async (
    { iin, access }: { iin: string; access: string },
    { rejectWithValue }
  ) => {
    try {
      const res = await searchConscriptApi(iin, access);
      return { results: [res], params: { iin, role: "conscript" as const } };
    } catch (err: any) {
      return rejectWithValue(err.message || "Призывник не найден");
    }
  }
);

export const searchCoordinator = createAsyncThunk(
  "search/searchCoordinator",
  async (
    { iin, access }: { iin: string; access: string },
    { rejectWithValue }
  ) => {
    try {
      const res = await searchCoordinatorApi(iin, access);
      return { results: [res], params: { iin, role: "coordinator" as const } };
    } catch (err: any) {
      return rejectWithValue(err.message || "Координатор не найден");
    }
  }
);

const searchSlice = createSlice({
  name: "search",
  initialState,
  reducers: {
    clearSearchResults: (state) => {
      state.searchResults = null;
      state.error = null;
      state.lastSearchParams = null;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Search user
      .addCase(searchUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(searchUser.fulfilled, (state, action) => {
        state.loading = false;
        state.searchResults = action.payload.results;
        state.lastSearchParams = action.payload.params;
      })
      .addCase(searchUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
        state.searchResults = null;
      })
      // Search conscript
      .addCase(searchConscript.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(searchConscript.fulfilled, (state, action) => {
        state.loading = false;
        state.searchResults = action.payload.results;
        state.lastSearchParams = action.payload.params;
      })
      .addCase(searchConscript.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
        state.searchResults = null;
      })
      // Search coordinator
      .addCase(searchCoordinator.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(searchCoordinator.fulfilled, (state, action) => {
        state.loading = false;
        state.searchResults = action.payload.results;
        state.lastSearchParams = action.payload.params;
      })
      .addCase(searchCoordinator.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
        state.searchResults = null;
      });
  },
});

export const { clearSearchResults, clearError } = searchSlice.actions;
export default searchSlice.reducer;
</file>

<file path="types/application.ts">
import { MedicalSpeciality, User } from "./user";

export interface Application {
  id: number;
  application_number: string;
  applicant: User;
  coordinator: User;
  status: string; // draft? enum idk
  status_display: string;
  contact_phone: string;
  contact_email: string;
  current_address: string;
  preferred_date: string | null;
  preferred_time: string | null;
  special_requirements: string;
  has_chronic_diseases: boolean;
  chronic_diseases_description: string;
  takes_medications: boolean;
  medications_description: string;
  has_allergies: boolean;
  allergies_description: string;
  coordinator_notes: string;
  scheduled_date: string | null;
  lmo: number;
  created_at: string;
  updated_at: string;
  completed_at: string | null;
  documents: []; // gotta add document type
  days_since_submitted: number;
  can_edit: boolean;
  detailed_status: string;
}

export interface MedicalRecord {
  id: number;
  doctor: User;
  doctor_specialty: string;
  examination_date: string;
  examination_date_formatted: string;
  diagnosis: string;
  recommendations: string;
  // measurements: []idk;
  vision_od: string;
  vision_os: string;
  color_vision: string;
  hearing_ad: string;
  hearing_as: string;
  is_signed: boolean;
  signature_date: string;
  // attachments: idk
}

export interface DoctorQueueElement {
  id: number;
  specialty: MedicalSpeciality;
  order: number;
  is_completed: boolean;
  assigned_doctor: User | null;
  assigned_doctor_name: string | null;
}

export interface LMO {
  id: number;
  number: string;
  conscript: User;
  coordinator: User;
  status: string; // (enum better)
  status_display: string;
  odo_region: string;
  osp_ddo_region: string;
  assigned_team: string;
  height: number;
  weight: number;
  chest_circumference: number;
  spirometry: string;
  bmi: number;
  fitness_category: string;
  fitness_category_display: string;
  final_diagnosis: string;
  commission_notes: string;
  created_at: string;
  updated_at: string;
  completed_at: string | null;
  doctor_queue: DoctorQueueElement[];
  medical_records: MedicalRecord[];
  completed_specialties: MedicalSpeciality[];
  pending_specialties: MedicalSpeciality[];
  progress_percentage: number;
  current_stage: string; // enum better i guess
}

export interface CreateApplicationResponse {
  application: Application;
  lmo: LMO;
}

// export interface GetApplicationsResponse {
//   applications: Application[]
// }
</file>

<file path="store/slices/authSlice.ts">
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import {
  login as loginApi,
  getMe as getMeApi,
  ecpLogin as ecpLoginApi,
} from "@/api/auth";
import type { User } from "@/types/user";
import { getTokenCookie, setTokenCookie, removeTokenCookie } from "@/utils/api";

interface AuthState {
  access: string | null;
  refresh: string | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
  user: User | null;
}

const initialState: AuthState = {
  access: null,
  refresh: null,
  isAuthenticated: false,
  loading: false,
  error: null,
  user: null,
};

// Async thunks остаются без изменений
export const login = createAsyncThunk(
  "auth/login",
  async (data: { iin: string; password: string }, { rejectWithValue }) => {
    try {
      const res = await loginApi(data);
      return res;
    } catch (err: any) {
      return rejectWithValue(err?.response?.data?.message || "Ошибка входа");
    }
  }
);

export const getMe = createAsyncThunk(
  "auth/getMe",
  async (access: string, { rejectWithValue }) => {
    try {
      const res = await getMeApi(access);
      return res;
    } catch (err: any) {
      return rejectWithValue("Ошибка получения пользователя");
    }
  }
);

export const ecpLogin = createAsyncThunk(
  "auth/ecpLogin",
  async (
    data: { p12_base64: string; password: string },
    { rejectWithValue }
  ) => {
    try {
      const res = await ecpLoginApi(data);
      return res;
    } catch (err: any) {
      return rejectWithValue(
        err?.response?.data?.message || "Ошибка входа по ЭЦП"
      );
    }
  }
);

const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    logout: (state) => {
      state.access = null;
      state.refresh = null;
      state.isAuthenticated = false;
      state.error = null;
      state.user = null;
      removeTokenCookie("access");
      removeTokenCookie("refresh");
    },
    setTokens: (
      state,
      action: PayloadAction<{ access: string; refresh: string }>
    ) => {
      state.access = action.payload.access;
      state.refresh = action.payload.refresh;
      state.isAuthenticated = true;
      setTokenCookie("access", action.payload.access);
      setTokenCookie("refresh", action.payload.refresh);
    },
    rehydrateAuth: (state) => {
      const access = getTokenCookie("access");
      const refresh = getTokenCookie("refresh");
      if (access) {
        state.access = access;
        state.isAuthenticated = true;
      }
      if (refresh) {
        state.refresh = refresh;
      }
    },
  },
  extraReducers: (builder) => {
    // Остальная логика остается без изменений
    builder
      .addCase(login.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action) => {
        state.loading = false;
        state.access = action.payload.access;
        state.refresh = action.payload.refresh;
        state.isAuthenticated = true;
        setTokenCookie("access", action.payload.access);
        setTokenCookie("refresh", action.payload.refresh);
      })
      .addCase(login.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(getMe.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(getMe.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload;
      })
      .addCase(getMe.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(ecpLogin.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(ecpLogin.fulfilled, (state, action) => {
        state.loading = false;
        state.access = action.payload.access;
        state.refresh = action.payload.refresh;
        state.user = action.payload.user;
        state.isAuthenticated = true;
        setTokenCookie("access", action.payload.access);
        setTokenCookie("refresh", action.payload.refresh);
      })
      .addCase(ecpLogin.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export const { logout, setTokens, rehydrateAuth } = authSlice.actions;
export default authSlice.reducer;
</file>

<file path="types/user.ts">
export interface MedicalSpeciality {
  id: number;
  name: string;
  code: string;
  description: string;
  order: number;
}

export interface DoctorProfile {
  specialty: MedicalSpeciality;
  specialty_id: number;
  license_number: string;
  experience_years: number;
  department: string;
  digital_signature_active: boolean;
}

export interface CoordinatorProfile {
  region: string;
  district: string;
  position: string;
}

export interface User {
  id: number;
  iin: string;
  role: string;
  first_name: string;
  last_name: string;
  middle_name: string;
  full_name: string;
  birth_date: string;
  age: number | string;
  nationality: string;
  phone: string;
  email: string;
  education: string;
  specialty: string;
  sport_category: string;
  height: number;
  weight: number;
  bmi: number | string;
  chest_circumference: number;
  spirometry: string;
  is_verified: boolean;
  created_at: string;
  doctor_profile: DoctorProfile | null;
  coordinator_profile: CoordinatorProfile | null;
}

export interface DoctorList {
  id: number;
  full_name: string;
  doctor_profile: DoctorProfile;
}
</file>

<file path="utils/api.ts">
import axios from "axios";
import { store } from "@/store";
import { refreshToken as refreshTokenApi } from "@/api/auth";
import { setTokens, logout } from "@/store/slices/authSlice";
import { serialize, parse } from "cookie";

let isRefreshing = false;
let failedQueue: any[] = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";

export const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    "Content-Type": "application/json",
  },
});

export function setTokenCookie(name: string, value: string, days = 7) {
  document.cookie = serialize(name, value, {
    path: "/",
    maxAge: 60 * 60 * 24 * days,
    secure: true,
    sameSite: "lax",
  });
}

export function getTokenCookie(name: string): string | null {
  if (typeof document === "undefined") return null;
  const cookies = parse(document.cookie || "");
  return cookies[name] || null;
}

export function removeTokenCookie(name: string) {
  document.cookie = serialize(name, "", {
    path: "/",
    maxAge: -1,
  });
}

api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    if (
      error.response &&
      error.response.status === 401 &&
      error.response.data?.code === "token_not_valid" &&
      !originalRequest._retry
    ) {
      originalRequest._retry = true;
      if (isRefreshing) {
        return new Promise(function (resolve, reject) {
          failedQueue.push({ resolve, reject });
        })
          .then((token) => {
            originalRequest.headers["Authorization"] = "Bearer " + token;
            return api(originalRequest);
          })
          .catch((err) => {
            return Promise.reject(err);
          });
      }
      isRefreshing = true;
      const refresh = getTokenCookie("refresh");
      if (!refresh) {
        store.dispatch(logout());
        isRefreshing = false;
        return Promise.reject(error);
      }
      try {
        const data = await refreshTokenApi(refresh);
        store.dispatch(
          setTokens({ access: data.access, refresh: data.refresh || refresh })
        );
        setTokenCookie("access", data.access);
        if (data.refresh) setTokenCookie("refresh", data.refresh);
        api.defaults.headers["Authorization"] = "Bearer " + data.access;
        processQueue(null, data.access);
        originalRequest.headers["Authorization"] = "Bearer " + data.access;
        return api(originalRequest);
      } catch (err) {
        processQueue(err, null);
        store.dispatch(logout());
        return Promise.reject(err);
      } finally {
        isRefreshing = false;
      }
    }
    return Promise.reject(error);
  }
);
</file>

<file path="store/index.ts">
import { configureStore } from "@reduxjs/toolkit";
import authReducer, { setTokens, logout } from "./slices/authSlice";
import recruitDashboardReducer from "./slices/recruitDashboardSlice";
import coordinatorDashboardReducer from "./slices/coordinatorDashboardSlice";
import searchReducer from "./slices/searchSlice";
import applicationReducer from "./slices/applicationSlice";
import conscriptsReducer from "./slices/conscriptsSlice";
import { api } from "../utils/api";
import { setupInterceptors } from "../utils/apiInterceptors";
import { refreshToken } from "../api/auth";

export const store = configureStore({
  reducer: {
    auth: authReducer,
    recruitDashboard: recruitDashboardReducer,
    coordinatorDashboard: coordinatorDashboardReducer,
    application: applicationReducer,
    conscripts: conscriptsReducer,
    search: searchReducer,
  },
});

// Настройка интерцепторов после создания store
setupInterceptors(
  api,
  (access: string, refresh?: string) => {
    store.dispatch(
      setTokens({
        access,
        refresh: refresh || store.getState().auth.refresh || "",
      })
    );
  },
  () => {
    store.dispatch(logout());
  },
  refreshToken
);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
</file>

</files>
